}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
start_vec[11]
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - threshold
while (TRUE) {
xt1 = xt - dg(xt) / estimate_d2g(xt, xt_1)
if(is.na(xt1)){
print(xt)
print(xt_1)
print(estimate_d2g(xt, xt_1))
}
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - threshold
while (TRUE) {
d2g = estimate_d2g(xt, xt_1)
if(is.na(d2g) || d2g == 0){
xt1 = 0
cat("The second order derivative is:", d2g, "\n")
break
}
xt1 = xt - dg(xt) / d2g
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - threshold
while (TRUE) {
if(is.na(estimate_d2g(xt, xt_1))){
xt1 = 0
cat("The second order derivative is:", d2g, "\n")
break
}
else{
d2g = estimate_d2g(xt, xt_1)
}
xt1 = xt - dg(xt) / d2g
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - threshold
while (TRUE) {
if(is.na(estimate_d2g(xt, xt_1))){
xt1 = 0
cat("When xt =",xt,"xt-1 =",xt_1,", the second order derivative is Nan.\n")
break
}
else{
d2g = estimate_d2g(xt, xt_1)
}
xt1 = xt - dg(xt) / d2g
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - threshold
while (TRUE) {
if(is.na(estimate_d2g(xt, xt_1))){
xt1 = 0
# cat("When xt =",xt,"xt-1 =",xt_1,", the second order derivative is Nan.\n")
cat("When xt =",xt,"xt-1 =",xt_1,"\n")
break
}
else{
d2g = estimate_d2g(xt, xt_1)
}
xt1 = xt - dg(xt) / d2g
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
debug(secant)
secant(start=1.5, threshold=0.001)
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - 0.1
while (TRUE) {
if(is.na(estimate_d2g(xt, xt_1))){
xt1 = 0
# cat("When xt =",xt,"xt-1 =",xt_1,", the second order derivative is Nan.\n")
cat("When xt =",xt,"xt-1 =",xt_1,"\n")
break
}
else{
d2g = estimate_d2g(xt, xt_1)
}
xt1 = xt - dg(xt) / d2g
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
debug(secant)
secant(start=1.5, threshold=0.001)
g = function(x){
gx = log(x + 1) / (x ^ 1.5 + 1)
return(gx)
}
dg = function(x){
dux = 1 / (x+1)
ux = log(x+1)
dvx = 1.5 * sqrt(x)
vx = x ^ 1.5 + 1
dg = (dux*vx - dvx*ux) / (vx ^ 2)
return(dg)
}
estimate_d2g = function(xt, xt_1){
return((dg(xt) - dg(xt_1)) / (xt - xt_1))
}
bisection = function(a, b, threshold = 0.001) {
est_list = vector("list", length(a))
for (i in seq_along(a)) {
left = a[i]
right = b[i]
while (abs(left - right) > threshold) {
mid = (left + right) / 2
dg_mid = dg(mid)
dg_left = dg(left)
dg_right = dg(right)
if (dg_left * dg_mid <= 0) {
right = mid
} else if (dg_right * dg_mid < 0) {
left = mid
}
else{
cat("The maximum is out of [",left,",",right,"].\n")
break
}
if (abs(left - right) <= threshold) break
}
est_list[[i]] = (left + right) / 2
}
return(unlist(est_list))
}
secant = function(start, threshold) {
xt1_list = vector("list", length(start))
for (x0 in start) {
xt = x0
xt_1 = x0 - 0.1
while (TRUE) {
d2g = tryCatch({
estimate_d2g(xt, xt_1)
}, warning = function(w) {
cat("When xt =",xt,"xt-1 =",xt_1,", the second order derivative is Nan.\n")
return(1)
})
if(d2g == 1){
xt = 0
break
}
xt1 = xt - dg(xt) / d2g
if (abs(xt1 - xt) < threshold) {
break
}
xt_1 = xt
xt = xt1
}
xt1_list[[which(start == x0)]] = xt
}
return(unlist(xt1_list))
}
a_vec = seq(from = 0.5, to = 1.0, by = 0.1)
b_vec = seq(from = 0.9, to = 1.4, by = 0.1)
start_vec = seq(from = 0.5, to = 2, by = 0.1)
cat("Bisection Method \n")
bisection(a = a_vec, b = b_vec, threshold = threshold)
cat("Secant Method \n")
secant(start = start_vec, threshold = threshold)
debug(secant)
